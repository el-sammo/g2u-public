
var Promise = require('bluebird');
var _ = require('lodash');

/**
 * Default datatable parameters.
 *
 * @see http://www.datatables.net/manual/server-side
 */
var defaultOptions = {
  /**
   * Draw counter. This is used by DataTables to ensure that the Ajax returns
   * from server-side processing requests are drawn in sequence by DataTables
   * (Ajax requests are asynchronous and thus can return out of sequence). This
   * is used as part of the draw return parameter (see below).
   */
  draw: 0,

  /**
   * Paging first record indicator. This is the start point in the current data
   * set (0 index based - i.e. 0 is the first record).
   */
  start: 0,

  /**
   * Number of records that the table can display in the current draw. It is
   * expected that the number of records returned will be equal to this number,
   * unless the server has fewer records to return. Note that this can be -1 to
   * indicate that all records should be returned (although that negates any
   * benefits of server-side processing!)
   */
  length: 20,

  /**
   * Search object
   */
  search: {
    /**
     * Global search value. To be applied to all columns which have searchable
     * as true.
     *
     * value: SEARCH_FOR,
     */

    /**
     * true if the global filter should be treated as a regular expression for
     * advanced searching, false otherwise. Note that normally server-side
     * processing scripts will not perform regular expression searching for
     * performance reasons on large data sets, but it is technically possible
     * and at the discretion of your script.
     *
     * regex: true | false,
     */
  },

  /**
   * Order grid
   */
  order: [
    /**
     * Column to which ordering should be applied. This is an index reference
     * to the columns array of information that is also submitted to the 
     * server.
     *
     * column: COLUMN_IDX,
     */

    /**
     * Ordering direction for this column. It will be asc or desc to indicate
     * ascending ordering or descending ordering, respectively.
     *
     * dir: 'asc' | 'desc',
     */
  ],

  /**
   * Columns grid
   */
  columns: [

    /**
     * Column's data source, as defined by columns.data|DT.
     *
     * data: DATA_SRC,
     */

    /**
     * Column's name, as defined by columns.name|DT.
     *
     * name: COL_NAME,
     */

    /**
     * Flag to indicate if this column is searchable (true) or not (false).
     * This is controlled by columns.searchable|DT.
     *
     * searchable: true | false,
     */

    /**
     * Flag to indicate if this column is orderable (true) or not (false). This
     * is controlled by columns.orderable|DT.
     *
     * orderable: true | false,
     */

    /**
     * Search value to apply to this specific column.
     *
     * search.value: SEARCH_FOR,
     */

    /**
     * Flag to indicate if the search term for this column should be treated
     * as regular expression (true) or not (false). As with global search, 
     * normally server-side processing scripts will not perform regular 
     * expression searching for performance reasons on large data sets, but 
     * it is technically possible and at the discretion of your script.
     *
     * search.regex: true | false,
     */
  ]
};

module.exports = function(model) {

  /**
   * Returns a promise to handle datatable options and fulfill
   * datatable expectations.
   *
   * @see http://www.datatables.net/manual/server-side
   */
  model.datatables = function(options) {
    var self = this;

    options = transformOptions(options);
    // console.log(JSON.stringify(options));

    return new Promise(function(resolve, reject) {
      var results;

      var find = buildFind(self, options);

      Promise.join(
        self.count(),
        find,
        function onResult(count, docs) {
          if(self.dtTransform) {
            docs = self.dtTransform(docs, options);
          } else {
            docs = genericDocsTransform(docs, options);
          }

          results.recordsTotal = count;
          results.recordsFiltered = count;
          results.data = docs;
          resolve(results);
        }
      ).catch(function onErr(err) {
        reject(err);
      });

      results = {
        draw: parseInt(options.draw),
        recordsTotal: 0,
        recordsFiltered: 0,
        data: [],
        // error: ''
      };
    });
  }

};

function buildFind(model, options) {
  var query = buildSearchQuery(options);
  var find = model.find(query).skip(options.start).limit(options.length);
  var sort = {};

  if(options.order.length > 0) {
    options.order.forEach(function(sortCriteria) {
      sort[getColumn(sortCriteria.column, options)] = sortCriteria.dir;
    });

    find.sort(sort);
  }

  return find;
}

function buildSearchQuery(options) {
  var query = {};

  if(! options.search.value) return query;

  var subqueries = [];
  options.columns.forEach(function(column) {
    if(! column.searchable) return;
    var subquery = {};
    subquery[column.data] = {contains: options.search.value};
    subqueries.push(subquery);
  });
  query = {or: subqueries};

  return query;
}

function getColumn(colIdx, options) {
  return options.columns[colIdx].data;
}

function transformOptions(options) {
  var trx = _({}).extend(defaultOptions, options).pick([
    'draw', 'start', 'length', 'search', 'order', 'columns'
  ]).value();

  trx.search = _(trx.search).pick(['value', 'regex']).value();

  ['draw', 'start', 'length'].forEach(function(key) {
    trx[key] = parseInt(trx[key]);
  });

  if(trx.search.regex) trx.search.regex = parseBoolean(trx.search.regex);

  trx.order = transformOrder(trx.order);
  trx.columns = transformColumns(trx.columns);

  return trx;
}

function transformOrder(order) {
  var trx = [];

  order.forEach(function(row) {
    trx.push({
      column: parseInt(row.column),
      dir: (row.dir === 'asc' ? 'asc' : 'desc')
    });
  });

  return trx;
}

function transformColumns(columns) {
  var trx = [];

  columns.forEach(function(row) {
    var trxRow = _.pick(row, ['data', 'name']);

    if(! _.isUndefined(row.searchable)) {
      trxRow.searchable = parseBoolean(row.searchable);
    }

    if(! _.isUndefined(row.orderable)) {
      trxRow.orderable = parseBoolean(row.orderable);
    }

    if(row.search) {
      trxRow.search = {
        value: row.search.value,
        regex: parseBoolean(row.search.regex),
      };
    }

    trx.push(trxRow);
  });

  return trx;
}

function genericDocsTransform(docs, options) {
  var columns = [];
  options.columns.forEach(function(col) {
    columns.push(col.data);
  });

  var transformed = [];
  docs.forEach(function(row) {
    transformed.push(_.pick(row, columns));
  });

  return transformed;
}

function parseBoolean(bool) {
  if(_.isString(bool)) return bool == 'true';
  return !!bool;
}

